<!-- npm run build -->
    Сайт написан на React c использованием SCSS и Bootstrap.
    По внешнему виду сайта я не заморачивался, так как суть задания в том, чтобы посмотреть, как справляюсь в запросами. Использовал самое привычное для меня - это fetch API. 
    Ошибки обрабатываются в отдельном классе Service, который и производит запросы по заданному АПИ и выводятся в консоль. Далее, как и требовалось, производится повторный запрос (до положительного результата). В этом же классе реализованы все методы, представленные в самом АПИ. К стати я бы все-таки метод получения фильтованных данных по цене изменил. Логичнее по передаваемому параметру выдавать диапазон товаров от ноля до указанного аргумента, а не товары только указанной цены. 
    При первичной загрузке страницы стартуем со стандарного запроса для получения 50 первых позиций товаров. Пагинация данных сделана так же по 50 товаров в обе стороны. Редкий вывод менее 50 позиций товаров обуслослен тем, что после получения ответа от сервера по методу get_items иногда приходят дублированные данные, которые просто пропускаются после получения. Для красоты можно было бы делать дополнительный запрос, по которому мы бы добавляли недостающее количество тованых позиций до необходимых 50, но в данном случае специально не делал этого. При проверке задания считаю, что количество товаров на странице- это то, на что будут обращать внимание, зная сам факт наличия таких "клонов". Проще увидеть, что товаров меньше, чем проверять каждый элемент на предмет отсутствия повторов. В продакшн естественно такое не отдавал бы, считаю это багом, оставляю его намеренно.
    Получение данных с сортировкой осуществляется после выполнения обязательного условия: выбран фильтр и есть данные, по которым будет осуществляться запрос(в едиственном инпуте). Пагинация такая же, как и при получении данных без фильтра, но есть небольшое отличие. Ввиду того, что данных может быть огромное количество, в них могут быть и картинки и каждый раз при переключении на следующий 50 элементов делать запрос на получение всего массива данных и исполозовать только 50 из них- это необоснованная нагрузка на сервер. Поэтому при неизменных типе фильтра и фразе для фильтрации запросы не повторяются. Делается один запрос, получаются все данные, а по нажатию на кнопку "следующая" или "предыдущая", просто отдается соответствующая часть целого массива в компонент Goods. 

    P.S.
    В целом, видя количество человек, претендующих на данную вакансию, здраво оцениваю свои шансы, но остаюсь с надеждой на лучшее. Но все равно благодарен за то, что дали возможность выполнить данное задание. Для меня это ценный опыт, который мне пригодится в жизни)